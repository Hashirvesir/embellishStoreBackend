import { jsx as e, jsxs as s } from "react/jsx-runtime";
import * as l from "react";
import { Cross as U } from "@strapi/icons";
import Z, { css as O } from "styled-components";
import { Root as ee, Trigger as re, Value as te, Portal as ne, Content as oe, Viewport as ie, Item as F, ItemIndicator as M, ItemText as le, Group as de } from "./SelectParts.js";
import ce from "../BaseCheckbox/assets/checkmark.svg.js";
import { stripReactIdOfColon as ae } from "../helpers/strings.js";
import { useComposedRefs as se } from "../hooks/useComposeRefs.js";
import { useId as S } from "../hooks/useId.js";
import { useIntersection as he } from "../hooks/useIntersection.js";
import { Tag as pe } from "../Tag/Tag.js";
import { Field as ue } from "../Field/Field.js";
import { Flex as fe } from "../Flex/Flex.js";
import { FieldLabel as me } from "../Field/FieldLabel.js";
import { Box as m } from "../Box/Box.js";
import { FieldHint as ge } from "../Field/FieldHint.js";
import { FieldError as xe } from "../Field/FieldError.js";
import { Typography as B } from "../Typography/Typography.js";
const ze = l.forwardRef(({ "aria-label": t, children: n, clearLabel: o = "Clear", customizeContent: d, disabled: i, error: c, hint: h, id: g, label: x, labelAction: V, onChange: u, onClear: j, onReachEnd: $, placeholder: E, required: R, selectButtonTitle: Ie, startIcon: z, size: A = "M", value: p, withTags: b, ...G }, W) => {
  const C = l.useRef(null), [k, w] = l.useState(), [q, H] = l.useState(!1), f = S(g), P = `${f}-hint`, X = `${f}-error`, Y = (r) => {
    u ? u(r) : w(r);
  }, _ = (r) => () => {
    const T = Array.isArray(p) ? p.filter((I) => I !== r) : (k ?? []).filter((I) => I !== r);
    u ? u(T) : w(T);
  }, D = (r) => {
    H(r);
  }, v = l.useRef(null), J = () => {
    v.current.focus();
  }, K = S(), y = `intersection-${ae(K)}`;
  he(C, (r) => {
    $ && $(r);
  }, {
    selectorToWatch: `#${y}`,
    /**
     * We need to know when the select is open because only then will viewportRef
     * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
     */
    skipWhen: !q
  });
  const a = typeof p < "u" && p !== null ? p : k, N = (r) => r && typeof r == "object" && r.value ? e(pe, { tabIndex: -1, disabled: i, icon: e(U, {}), onClick: _(r.value), children: r.textValue }, r.value) : null, Q = se(v, W);
  return e(ue, { hint: h, error: c, id: f, required: R, children: s(fe, { direction: "column", alignItems: "stretch", gap: 1, children: [x ? e(me, { onClick: J, action: V, children: x }) : null, s(ee, { onOpenChange: D, disabled: i, required: R, onValueChange: Y, value: a, ...G, multi: !0, children: [e(re, { ref: Q, "aria-label": x ?? t, "aria-describedby": `${P} ${X}`, id: f, startIcon: z, size: A, hasError: !!c, disabled: i, clearLabel: o, onClear: a?.length ? j : void 0, paddingLeft: b && a?.length ? 1 : 3, children: e(te, { placeholder: E, textColor: a?.length ? "neutral800" : "neutral600", children: a?.length ? b ? N : d ? d(a) : void 0 : void 0 }) }), e(ne, { children: e(oe, { position: "popper", sideOffset: 4, children: s(ie, { ref: C, children: [n, e(m, { id: y, width: "100%", height: "1px" })] }) }) })] }), e(ge, {}), e(xe, {})] }) });
}), Ae = l.forwardRef(({ value: t, children: n, startIcon: o, ...d }, i) => s(F, { ref: i, value: t.toString(), ...d, children: [o && e(m, { as: "span", "aria-hidden": !0, children: o }), e(M, { children: ({ isSelected: c, isIntermediate: h }) => e(L, { hasRadius: !0, overflow: "hidden", position: "relative", $indeterminate: h, $selected: c, zIndex: 1, height: "18px", width: "18px" }) }), e(B, { textColor: "neutral800", children: e(le, { children: n }) })] })), L = Z(m)`
  border: 1px solid
    ${({ theme: t, $selected: n, $indeterminate: o }) => n || o ? t.colors.primary600 : t.colors.neutral300};
  background-color: ${({ theme: t, $selected: n, $indeterminate: o }) => n || o ? t.colors.primary600 : t.colors.neutral0};

  ${({ theme: t, $indeterminate: n }) => n && O`
      &::after {
        content: '';
        display: block;
        position: relative;
        color: white;
        height: 2px;
        width: 10px;
        background-color: ${t.colors.neutral0};
        left: 50%;
        top: 50%;
        transform: translateX(-50%) translateY(-50%);
      }
    `}

  ${({ $selected: t }) => t && O`
      &::after {
        content: '';
        background: url(${ce}) no-repeat no-repeat center center;
        width: 100%;
        height: 100%;
        position: absolute;
      }
    `}
`, Ge = l.forwardRef(({ children: t, label: n, startIcon: o, values: d = [], ...i }, c) => s(de, { ref: c, children: [s(F, { value: d, ...i, children: [o && e(m, { as: "span", "aria-hidden": !0, children: o }), e(M, { children: ({ isSelected: h, isIntermediate: g }) => e(L, { hasRadius: !0, overflow: "hidden", position: "relative", $indeterminate: g, $selected: h, zIndex: 1, height: "18px", width: "18px" }) }), e(B, { textColor: "neutral800", children: n })] }), t] }));
export {
  ze as MultiSelect,
  Ge as MultiSelectGroup,
  Ae as MultiSelectOption
};
