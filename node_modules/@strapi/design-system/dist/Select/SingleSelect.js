import { jsx as e, jsxs as h } from "react/jsx-runtime";
import * as o from "react";
import { Root as q, Trigger as W, Value as _, Portal as H, Content as M, Viewport as P, Item as z, ItemText as A } from "./SelectParts.js";
import { stripReactIdOfColon as D } from "../helpers/strings.js";
import { useComposedRefs as G } from "../hooks/useComposeRefs.js";
import { useId as C } from "../hooks/useId.js";
import { useIntersection as J } from "../hooks/useIntersection.js";
import { Field as K } from "../Field/Field.js";
import { Flex as Q } from "../Flex/Flex.js";
import { FieldLabel as U } from "../Field/FieldLabel.js";
import { FieldHint as X } from "../Field/FieldHint.js";
import { FieldError as Y } from "../Field/FieldError.js";
import { Box as T } from "../Box/Box.js";
import { Typography as Z } from "../Typography/Typography.js";
const Ie = o.forwardRef(({ error: d, hint: r, id: c, label: n, labelAction: i, required: s, selectButtonTitle: R, ...m }, a) => {
  const l = C(c), f = o.useRef(null), g = () => {
    f.current.focus();
  }, I = G(a, f);
  return e(K, { hint: r, error: d, id: l, required: s, children: h(Q, { direction: "column", alignItems: "stretch", gap: 1, children: [n ? e(U, { onClick: g, action: i, children: n }) : null, e(ee, { label: n, id: l, ref: I, required: s, ...m }), e(X, {}), e(Y, {})] }) });
}), ee = o.forwardRef(({ "aria-label": d, id: r, children: c, clearLabel: n = "Clear", customizeContent: i, disabled: s, error: R, label: m, onChange: a, onClear: l, onReachEnd: f, placeholder: g, required: I, selectButtonTitle: re, startIcon: B, size: O = "M", value: p, ...w }, F) => {
  const [$, S] = o.useState(), [y, k] = o.useState(!1), v = (t) => {
    k(t);
  }, E = (t) => {
    l && l(t), a || S("");
  }, L = `${r}-hint`, N = `${r}-error`, V = (t) => {
    a ? a(typeof p == "number" ? Number(t) : t) : S(t);
  }, b = o.useRef(null), j = C(), x = `intersection-${D(j)}`;
  J(b, (t) => {
    f && f(t);
  }, {
    selectorToWatch: `#${x}`,
    /**
     * We need to know when the select is open because only then will viewportRef
     * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
     */
    skipWhen: !y
  });
  const u = (typeof p < "u" && p !== null ? p.toString() : $) ?? "";
  return h(q, { onOpenChange: v, disabled: s, required: I, onValueChange: V, value: u, ...w, children: [e(W, { ref: F, "aria-label": m ?? d, "aria-describedby": r ? `${L} ${N}` : void 0, id: r, startIcon: B, size: O, hasError: !!R, disabled: s, clearLabel: n, onClear: u && l ? E : void 0, children: e(_, { placeholder: g, textColor: u ? "neutral800" : "neutral600", children: u && i ? i(u) : void 0 }) }), e(H, { children: e(M, { position: "popper", sideOffset: 4, children: h(P, { ref: b, children: [c, e(T, { id: x, width: "100%", height: "1px" })] }) }) })] });
}), Re = o.forwardRef(({ value: d, startIcon: r, children: c, ...n }, i) => h(z, { ref: i, value: d.toString(), ...n, children: [r && e(T, { as: "span", "aria-hidden": !0, children: r }), e(Z, { textColor: "neutral800", children: e(A, { children: c }) })] }));
export {
  Ie as SingleSelect,
  ee as SingleSelectInput,
  Re as SingleSelectOption
};
