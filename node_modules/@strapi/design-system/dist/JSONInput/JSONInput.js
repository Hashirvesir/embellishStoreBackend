import { jsx as i, jsxs as J } from "react/jsx-runtime";
import { forwardRef as j, useRef as d, useImperativeHandle as y } from "react";
import { json as L, jsonParseLinter as $ } from "@codemirror/lang-json";
import { useCodeMirror as V } from "@uiw/react-codemirror";
import v from "styled-components";
import { markField as z, addMarks as A, lineHighlightMark as B, filterMarks as q } from "./utils/decorationExtension.js";
import { useComposedRefs as G } from "../hooks/useComposeRefs.js";
import { Field as P } from "../Field/Field.js";
import { Flex as g } from "../Flex/Flex.js";
import { FieldLabel as D } from "../Field/FieldLabel.js";
import { FieldError as K } from "../Field/FieldError.js";
import { FieldHint as Q } from "../Field/FieldHint.js";
import { inputFocusStyle as T } from "../themes/utils.js";
const lr = j(({ label: t, error: c, hint: p, labelAction: b, value: S = "", required: E = !1, disabled: m = !1, onChange: k = () => null, ...F }, w) => {
  const u = d(), s = d(), l = d(), C = !!c, I = (r) => {
    const e = s.current?.doc;
    if (e) {
      const { text: a, to: n } = e.line(r), f = n - a.trimStart().length;
      n > f && l.current?.dispatch({
        effects: A.of([B.range(f, n)])
      });
    }
  }, x = () => {
    const r = s.current?.doc;
    if (r) {
      const e = r.length || 0;
      l.current?.dispatch({
        effects: q.of((a, n) => n <= 0 || a >= e)
      });
    }
  }, h = ({ state: r, view: e }) => {
    l.current = e, s.current = r, x();
    const n = $()(e);
    n.length && I(r.doc.lineAt(n[0].from).number);
  }, H = (r, e) => {
    h(e), k(r);
  }, M = (r, e) => {
    l.current = r, s.current = e, h({ view: r, state: e });
  }, { setContainer: N, view: o } = V({
    value: S,
    onCreateEditor: M,
    container: u.current,
    editable: !m,
    extensions: [L(), z],
    onChange: H,
    theme: "dark",
    basicSetup: {
      lineNumbers: !0,
      bracketMatching: !0,
      closeBrackets: !0,
      indentOnInput: !0,
      syntaxHighlighting: !0,
      highlightSelectionMatches: !0,
      tabSize: 2
    }
  }), O = () => {
    !m && o && o.focus();
  }, R = G(u, N);
  return y(w, () => ({
    ...o?.dom,
    focus() {
      o && o.focus();
    },
    scrollIntoView(r) {
      o && o.dom.scrollIntoView(r);
    }
  }), [o]), i(P, { error: c, hint: p, required: E, children: J(g, { direction: "column", alignItems: "stretch", gap: 1, children: [t && i(D, { onClick: O, action: b, children: t }), i(U, { ref: R, hasError: C, alignItems: "stretch", fontSize: 2, hasRadius: !0, ...F }), i(K, {}), i(Q, {})] }) });
}), U = v(g)`
  line-height: ${({ theme: t }) => t.lineHeights[2]};

  .cm-editor {
    /** 
     * Hard coded since the color is the same between themes,
     * theme.colors.neutral800 changes between themes 
     */
    background-color: #32324d;
    width: 100%;
    outline: none;
  }

  .cm-scroller {
    border: 1px solid ${({ theme: t, hasError: c }) => c ? t.colors.danger600 : t.colors.neutral200};
    /* inputFocusStyle will receive hasError prop */
    ${T()}
  }

  .cm-editor,
  .cm-scroller {
    border-radius: ${({ theme: t }) => t.borderRadius};
  }

  .cm-gutters,
  .cm-activeLineGutter {
    /** 
     * Hard coded since the color is the same between themes,
     * theme.colors.neutral700 changes between themes 
     */
    background-color: #4a4a6a;
  }
`;
export {
  lr as JSONInput
};
