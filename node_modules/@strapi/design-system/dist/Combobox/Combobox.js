import { jsxs as c, jsx as r } from "react/jsx-runtime";
import * as u from "react";
import { Cross as be, CarretDown as $e } from "@strapi/icons";
import { Combobox as n } from "@strapi/ui-primitives";
import l from "styled-components";
import { stripReactIdOfColon as Ce } from "../helpers/strings.js";
import { useComposedRefs as xe } from "../hooks/useComposeRefs.js";
import { useControllableState as w } from "../hooks/useControllableState.js";
import { useId as R } from "../hooks/useId.js";
import { useIntersection as Ie } from "../hooks/useIntersection.js";
import { Loader as we } from "../Loader/Loader.js";
import { getThemeSize as Re, inputFocusStyle as ve } from "../themes/utils.js";
import { Flex as g } from "../Flex/Flex.js";
import { Box as v } from "../Box/Box.js";
import { Typography as f } from "../Typography/Typography.js";
import { Field as ye } from "../Field/Field.js";
import { FieldLabel as ke } from "../Field/FieldLabel.js";
import { FieldHint as Te } from "../Field/FieldHint.js";
import { FieldError as Ve } from "../Field/FieldError.js";
const Fe = u.forwardRef(({ allowCustomValue: e, autocomplete: o, children: h, className: a, clearLabel: s = "clear", creatable: i = !1, createMessage: b = (m) => `Create "${m}"`, defaultFilterValue: $, defaultTextValue: p, defaultOpen: W = !1, open: L, onOpenChange: U, disabled: C = !1, error: k, filterValue: A, hasMoreItems: G = !1, id: T, isPrintableCharacter: J, loading: x = !1, loadingMessage: K = "Loading content...", noOptionsMessage: M = () => "No results found", onChange: V, onClear: I, onCreateOption: F, onFilterValueChange: Q, onInputChange: O, onTextValueChange: X, onLoadMore: z, placeholder: Y = "Select or enter a value", required: Z = !1, size: _ = "M", startIcon: B, textValue: ee, value: P, ...re }, oe) => {
  const [m, te] = w({
    prop: L,
    defaultProp: W,
    onChange: U
  }), [d, S] = w({
    prop: ee,
    defaultProp: e && !p ? P : p,
    onChange: X
  }), [ne, j] = w({
    prop: A,
    defaultProp: $,
    onChange: Q
  }), E = u.useRef(null), q = u.useRef(null), ie = xe(q, oe), le = u.useRef(null), ae = (t) => {
    I && !C && (S(""), j(""), I(t), q.current.focus());
  }, se = (t) => {
    te(t);
  }, de = (t) => {
    S(t);
  }, ce = (t) => {
    j(t);
  }, ue = (t) => {
    O && O(t);
  }, he = (t) => {
    V && V(t);
  }, pe = (t) => {
    z && G && !x && z(t);
  }, N = () => {
    F && d && F(d);
  }, D = R(T), fe = R(), H = `intersection-${Ce(fe)}`;
  Ie(E, pe, {
    selectorToWatch: `#${H}`,
    /**
     * We need to know when the select is open because only then will viewportRef
     * not be null. Because it uses a portal that (sensibly) is not mounted 24/7.
     */
    skipWhen: !m
  });
  const me = `${D}-hint`, ge = `${D}-error`;
  return c(n.Root, { autocomplete: o || (i ? "list" : "both"), onOpenChange: se, open: m, onTextValueChange: de, textValue: d, allowCustomValue: i || e, disabled: C, required: Z, value: P, onValueChange: he, filterValue: ne, onFilterValueChange: ce, isPrintableCharacter: J, children: [c(Be, { $hasError: !!k, $size: _, className: a, children: [c(g, { flex: "1", as: "span", gap: 3, children: [B ? r(v, { as: "span", "aria-hidden": !0, children: B }) : null, r(Pe, { placeholder: Y, id: T, "aria-invalid": !!k, "aria-describedby": `${me} ${ge}`, onChange: ue, ref: ie, ...re })] }), c(g, { as: "span", gap: 3, children: [d && I ? r(ze, { as: "button", hasRadius: !0, background: "transparent", type: "button", onClick: ae, "aria-disabled": C, "aria-label": s, title: s, ref: le, children: r(be, {}) }) : null, r(Se, { children: r($e, {}) })] })] }), r(n.Portal, { children: r(je, { sideOffset: 4, children: c(Ee, { ref: E, children: [h, i ? r(n.CreateItem, { onPointerUp: N, onClick: N, asChild: !0, children: r(y, { children: r(f, { children: b(d ?? "") }) }) }) : null, !i && !x ? r(n.NoValueFound, { asChild: !0, children: r(y, { $hasHover: !1, children: r(f, { children: M(d ?? "") }) }) }) : null, x ? r(g, { justifyContent: "center", alignItems: "center", paddingTop: 2, paddingBottom: 2, children: r(we, { small: !0, children: K }) }) : null, r(v, { id: H, width: "100%", height: "1px" })] }) }) })] });
}), Oe = u.forwardRef(({ error: e, hint: o, id: h, label: a, labelAction: s, required: i = !1, ...b }, $) => {
  const p = R(h);
  return r(ye, { hint: o, error: e, id: p, required: i, children: c(g, { direction: "column", alignItems: "stretch", gap: 1, children: [a ? r(ke, { action: s, children: a }) : null, r(Fe, { ref: $, id: p, error: e, required: i, ...b }), r(Te, {}), r(Ve, {})] }) });
}), rr = (e) => r(Oe, { ...e, creatable: !0 }), ze = l(v)`
  border: none;

  svg {
    height: ${11 / 16}rem;
    width: ${11 / 16}rem;
  }

  svg path {
    fill: ${({ theme: e }) => e.colors.neutral600};
  }
`, Be = l(n.Trigger)`
  position: relative;
  border: 1px solid ${({ theme: e, $hasError: o }) => o ? e.colors.danger600 : e.colors.neutral200};
  padding-right: ${({ theme: e }) => e.spaces[3]};
  padding-left: ${({ theme: e }) => e.spaces[3]};
  border-radius: ${({ theme: e }) => e.borderRadius};
  background: ${({ theme: e }) => e.colors.neutral0};
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: ${({ theme: e }) => e.spaces[4]};
  min-height: ${({ theme: e, $size: o }) => Re("input")({ theme: e, size: o })};

  &[data-disabled] {
    color: ${({ theme: e }) => e.colors.neutral600};
    background: ${({ theme: e }) => e.colors.neutral150};
    cursor: not-allowed;
  }

  /* Required to ensure the below inputFocusStyles are adhered too */
  &:focus-visible {
    outline: none;
  }

  ${({ theme: e, $hasError: o }) => ve()({ theme: e, hasError: o })};
`, Pe = l(n.TextInput)`
  width: 100%;
  font-size: ${14 / 16}rem;
  color: ${({ theme: e }) => e.colors.neutral800};
  padding: 0;
  border: none;
  background-color: transparent;

  &:focus-visible {
    outline: none;
  }

  &[aria-disabled='true'] {
    cursor: inherit;
  }
`, Se = l(n.Icon)`
  & > svg {
    width: ${6 / 16}rem;

    & > path {
      fill: ${({ theme: e }) => e.colors.neutral600};
    }
  }

  &[aria-disabled='true'] {
    cursor: inherit;
  }
`, je = l(n.Content)`
  background: ${({ theme: e }) => e.colors.neutral0};
  box-shadow: ${({ theme: e }) => e.shadows.filterShadow};
  border: 1px solid ${({ theme: e }) => e.colors.neutral150};
  border-radius: ${({ theme: e }) => e.borderRadius};
  width: var(--radix-combobox-trigger-width);
  /* This is from the design-system figma file. */
  max-height: 15rem;
  z-index: ${({ theme: e }) => e.zIndices[1]};
`, Ee = l(n.Viewport)`
  padding: ${({ theme: e }) => e.spaces[1]};
`, or = u.forwardRef(({ children: e, value: o, disabled: h, textValue: a, ...s }, i) => r(n.ComboboxItem, { asChild: !0, value: o, disabled: h, textValue: a, children: r(y, { ref: i, ...s, children: r(n.ItemText, { asChild: !0, children: r(f, { children: e }) }) }) })), y = l.div`
  width: 100%;
  border: none;
  text-align: left;
  outline-offset: -3px;
  padding: ${({ theme: e }) => e.spaces[2]} ${({ theme: e }) => e.spaces[4]};
  background-color: ${({ theme: e }) => e.colors.neutral0};
  border-radius: ${({ theme: e }) => e.borderRadius};
  user-select: none;

  &[data-state='checked'] {
    background-color: ${({ theme: e }) => e.colors.primary100};

    ${f} {
      color: ${({ theme: e }) => e.colors.primary600};
      font-weight: bold;
    }
  }

  &:hover,
  &[data-highlighted] {
    outline: none;
    background-color: ${({ theme: e, $hasHover: o = !0 }) => o ? e.colors.primary100 : e.colors.neutral0};
  }

  &[data-highlighted] {
    ${f} {
      color: ${({ theme: e }) => e.colors.primary600};
      font-weight: bold;
    }
  }
`;
export {
  Oe as Combobox,
  Fe as ComboboxInput,
  rr as CreatableCombobox,
  or as Option,
  y as OptionBox
};
